#define OK 0
#define ERROR -1
#define RET_ERR return 1
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <lua5.4/lua.h>
#include <lua5.4/lualib.h>
#include <lua5.4/lauxlib.h>
#include <SDL2/SDL.h>
#include <SDL2/SDL_image.h>

#define MOONGIN

#ifndef MOONGIN 
    #include "includes.h"
#endif

typedef struct {
    int entries; int size;
    void **item;
} list_t;

void list_print(list_t *self){
    printf("list = { %d entries\n", self->entries);
    int i; for(i=0; i<self->entries; i++) {
        printf("    %d: %p\n", i, self->item[i]);
    }   printf("}\n");
}

list_t *list_new(int size){
    list_t *self = malloc(sizeof(list_t));
    self->entries = 0;
    self->size = size;
    self->item = malloc(sizeof(void*) * self->size);
    return self;
}

void list_add(list_t *self, void *item) {
    if (self->entries == self->size) {
        self->size *=2;
        self->item = realloc(self->item, sizeof(void*) * self->size);
    }   self->item[self->entries] = item;
    self->entries++;
}

void list_remove(list_t *self, int index) {
    int i; for(i=index; i<self->entries; i++) {
        self->item[i] = self->item[i+1];
    }
    if ( self->size < (self->entries/2) ) {
        self->size /=2;
        self->item = realloc(self->item, sizeof(void*) * self->size);
    }   self->entries--;
}

void list_concat(list_t *self, list_t *ref) {
    int i; for(i=0; i<ref->entries; i++) {
        list_add(self, ref->item[i]);
    }
}

bool list_find(list_t *self, void *item) {
    int i; for(i=0; i<self->entries; i++) {
        if (self->item[i] == item) { return true; }
    }   return false;
}

int list_index(list_t *self, void *item) {
    int i; for(i=0; i<self->entries; i++) {
        if (self->item[i] == item) { return i; }
    }   return false;   
} // list
#ifndef MOONGIN 
    #include "includes.h"
#endif
/*
    IDs look something like this:
        xx aa aa aa
    where (x) is the type and (a) is the actual index;
    typeof 0 is reserved for errors only

    For tag definitions, check glua.c or relevant headers
*/

list_t *global_item_table; // a list of lists, essentially

int item_newId(int type, int index) {
    int value = type + ( index << 8);
    return value;
}

bool item_isType(int type, int id) {
    int subtype = id % 255;
    return (type == subtype);
}

void *item_byInt(int id) {
    int type = id % 255;
    int value = id >> 8;
    if ( global_item_table->entries <= type ) { return NULL; }
    list_t *subTable = global_item_table->item[type];
    if ( subTable->entries <= value ) { return NULL; }
    return subTable->item[value];
}

void *item_byStr(const char *id){
    if (strlen(id) != 8) { return NULL; }
    int value; int i; for (i=0; i<8; i++) {
        if( id[i] <= 'f' && id[i] >= 'a' ){
            value *= 256;
            value += ( id[i] - 'a' + 10 );
        }
        else if ( id[i+2] <= '9' && id[i] >= '0' ) {
            value *= 256;
            value += ( id[i] - '0' );
        }
        else { return NULL; }
    }   return item_byInt(value);
} // item 
#ifndef MOONGIN 
    #include "includes.h"
#endif

int gsdl_init();
void gsdl_quit();

SDL_Window* gsdl_windowNew(const char *title, int width, int height, int flags);
SDL_Renderer *gsdl_newRenderer(SDL_Window *parentWindow, int rendererFlags);
void gsdl_windowDestroy(SDL_Window *window);
void gsdl_rendererDestroy(SDL_Renderer *renderer);
void gsdl_presentRenderer(SDL_Renderer *renderer);
bool gsdl_setColor(SDL_Renderer *renderer, char red, char green, char blue, char alpha);
void gsdl_clear(SDL_Renderer *renderer);
void gsdl_delay(int milliseconds);
SDL_Texture *gsdl_loadTexture(SDL_Renderer *renderer, const char *filename);
int gsdl_renderTexture(SDL_Renderer *renderer, SDL_Texture *texture, SDL_Rect src, SDL_Rect dest);
bool gsdl_pollEvent();

// ================================ GSDL Constant Objects

char pushfmtstr[255];
const SDL_Rect BadBox;
SDL_Event eventHandle; // gsdl header
#ifndef MOONGIN 
    #include "includes.h"
#endif
// ================================ Glua Functions

int glua_byterun(lua_State *context, const char *bytecode, int bytecode_size);
int glua_exit(lua_State *context);
int glua_getInt(lua_State *context, char *func, int arg);
double glua_getFloat(lua_State *context, char *func, int arg);
const char *glua_getString(lua_State *context, char *func, int arg);
SDL_Rect glua_getBox(lua_State *context, char *func, int arg);
void glua_subfield_string(lua_State *state, const char *field, const char *value);
void glua_subfield_int(lua_State *state, const char *field, int value);
void glua_enter_subtable(lua_State *state, const char *field);

// ================================ SDL Functions

int glua_newWindow(lua_State *context);
int glua_newRenderer(lua_State *context);
int glua_presentRenderer(lua_State *context);
int glua_destroyWindow(lua_State *context);
int glua_destroyRenderer(lua_State *context);
int glua_loadTexture(lua_State *context);
int glua_renderTexture(lua_State *context);
int glua_setColor(lua_State *context);
int glua_clear(lua_State *context);
int glua_delay(lua_State *context);
int glua_pollEvent(lua_State *context);

// ================================ ENTITY SYSTEM

int glua_getByIdInt(lua_State *context);
int glua_getByIdStr(lua_State *context);

// ================================ MAGIC VALUES

list_t *glua_windows;       int tag_windows = 0;
list_t *glua_renderers;     int tag_renderers = 1;
list_t *glua_textures;      int tag_textures = 2; 

const char sdls_index_out_of_range[] = "%s (arg %d) index out of range";
const char sdls_index_destroyed[] = "%s (arg %d) cannot reuse destroyed instance";
const char sdls_expect_int[] = "%s (arg %d) expected integer";
const char sdls_expect_float[] = "%s (arg %d) expected floating-point number";
const char sdls_expect_table[] = "%s (arg %d) expected table";
const char sdls_expect_table_bad[] = "%s (arg %d) table missing required values";
const char sdls_expect_string[] = "%s (arg %d) expected string";
const char sdls_wrong_type[] = "%s (arg %d) wrong data type";
const char sdls_invalid_id[] = "%s (arg %d) given invalid id";
const char sdls_unable_file[] = "%s (arg %d) returned NULL, check that the file exists and is readable";
const char sdls_unable_render[] = "%s (arg %d) failed to render to canvas";
const char sdls_unable_handle[] = "%s (type %d) failed to process event";
 // glua header
#ifndef MOONGIN 
    #include "includes.h"
#endif

void glua_event_common(lua_State *context);
void glua_event_keyboard(lua_State *context);
void glua_event_window(lua_State *context); // event header
#ifndef MOONGIN 
    #include "includes.h"
#endif

int gsdl_init() {
    if (SDL_Init(SDL_INIT_VIDEO) != 0) {
        printf("SDL_Init error: %s\n", SDL_GetError());
        return ERROR;
    }   return OK;
}

void gsdl_quit() { SDL_Quit(); }

SDL_Window* gsdl_windowNew(const char *title, int width, int height, int flags) {
    SDL_Window *window = SDL_CreateWindow(
        title,                  // Title of the window
        SDL_WINDOWPOS_CENTERED, // X position of the window
        SDL_WINDOWPOS_CENTERED, // Y position of the window
        width,                  // Window width
        height,                 // Window height
        flags
    );
    if (window == NULL) {
        printf("SDL_CreateWindow error: %s\n", SDL_GetError());
        SDL_Quit();  // Clean up SDL if window creation fails
        return NULL;  // Return NULL to indicate failure
    }   return window;
}

SDL_Renderer *gsdl_newRenderer(SDL_Window *parentWindow, int rendererFlags){
    SDL_Renderer *renderer = SDL_CreateRenderer(parentWindow, -1, rendererFlags);
    if (!renderer) { printf("SDL_CreateRenderer error: %s\n", SDL_GetError()); SDL_Quit(); return NULL; }
    return renderer;
}

void gsdl_windowDestroy(SDL_Window *window) { SDL_DestroyWindow(window); }
void gsdl_rendererDestroy(SDL_Renderer *renderer) { SDL_DestroyRenderer(renderer); }
void gsdl_presentRenderer(SDL_Renderer *renderer) { SDL_RenderPresent(renderer); }

bool gsdl_setColor(SDL_Renderer *renderer, char red, char green, char blue, char alpha) { return SDL_SetRenderDrawColor(renderer, red, green, blue, alpha); }
void gsdl_clear(SDL_Renderer *renderer) { SDL_RenderClear(renderer); SDL_RenderPresent(renderer); }
void gsdl_delay(int milliseconds) { SDL_Delay(milliseconds); }

SDL_Texture *gsdl_loadTexture(SDL_Renderer *renderer, const char *filename) { 
    SDL_Texture *ref = IMG_LoadTexture(renderer, filename);
    if ( ref == NULL ) { printf("SDL_loadTexture error: %s\n", SDL_GetError()); return NULL; } // don't quit; we can recover from these types of errors
    return ref;
}

int gsdl_renderTexture(SDL_Renderer *renderer, SDL_Texture *texture, SDL_Rect src, SDL_Rect dest) {
    return SDL_RenderCopy(renderer, texture, &src, &dest);
}

bool gsdl_pollEvent() { return SDL_PollEvent(&eventHandle); } // gsdl source
#ifndef MOONGIN 
    #include "includes.h"
#endif
void glua_error(lua_State *context, const char *fmt, const char *src, int arg) { sprintf(pushfmtstr, fmt, src, arg); lua_pushstring(context, pushfmtstr); lua_error(context); }

// ================ Get data on and off the stack

int glua_getInt(lua_State *context, char *func, int arg) {
    if (!lua_isnumber(context, -1)) {
        printf("ERR: type %s\n", lua_typename(context, lua_type(context, -1)));
        glua_error(context, sdls_expect_int, func, arg); 
        RET_ERR;
    }
    int value = lua_tointeger(context, -1);
    lua_pop(context, 1);  // Remove the top of the stack
    return value;
}

double glua_getFloat(lua_State *context, char *func, int arg) {
    if (!lua_isnumber(context, -1)) {
        glua_error(context, sdls_expect_float, func, arg);
        RET_ERR;
    }
    double value = lua_tonumber(context, -1);
    lua_pop(context, 1);
    return value;
}

const char *glua_getString(lua_State *context, char *func, int arg) {
    if (!lua_isstring(context, -1)) {
        glua_error(context, sdls_expect_string, func, arg);
        return NULL;
    }
    const char *value = lua_tostring(context, -1);
    lua_pop(context, 1);  // Remove the top of the stack
    return value;
}

SDL_Rect glua_getBox(lua_State *context, char *func, int arg) {
    // Ensure the argument is a table
    SDL_Rect rect;
    if (!lua_istable(context, -1)) { glua_error(context, sdls_expect_table, func, 0); return BadBox; }
    lua_getfield(context, -1, "x");  // consume the value of "x"
        rect.x = glua_getInt(context, func, 1);
        if ( rect.x == ERROR ) { return BadBox; }
    lua_getfield(context, -1, "y"); // consume the 'y' value
        rect.y = glua_getInt(context, func, 2);
        if ( rect.y == ERROR ) { return BadBox; }
    lua_getfield(context, -1, "w"); // consume the 'w' value
        rect.w = glua_getInt(context, func, 3);
        if ( rect.w == ERROR ) { return BadBox; }
    lua_getfield(context, -1, "h"); // consume the 'h' value
        rect.h = glua_getInt(context, func, 4);
        if ( rect.h == ERROR ) { return BadBox; }
    lua_pop(context, 1); // pop off the table
    return rect;
}

// ===================== SDL Rendering Functions

int glua_byterun(lua_State *context, const char *bytecode, int bytecode_size) {
    if (luaL_loadbuffer(context, bytecode, bytecode_size, "chunk") != LUA_OK) {
        printf("Error loading Lua module: %s\n", lua_tostring(context, -1));
        return ERROR;
    }
    if (lua_pcall(context, 0, LUA_MULTRET, 0) != LUA_OK) {
        printf("Error in Lua runtime: %s\n", lua_tostring(context, -1));
        return ERROR;
    }
    return OK;
}

int glua_exit(lua_State *context){
    int i; int status = glua_getInt(context, "core.exit", 1);
    int num_windows = glua_windows->entries;
    int num_renderers = glua_renderers->entries;
    for(i=0;i<num_windows;i++) { gsdl_windowDestroy( glua_windows->item[i] ); }
    for(i=0;i<num_renderers;i++) { gsdl_windowDestroy( glua_renderers->item[i] ); }
    gsdl_quit(); exit(status); 
}

int glua_newWindow(lua_State *context){
    int flags = glua_getInt(context, "gfx.newWindow", 4);
    int height = glua_getInt(context, "gfx.newWindow", 3);
    int width = glua_getInt(context, "gfx.newWindow", 2);
    const char *title = glua_getString(context, "gfx.newWindow", 1);
    if ( title == NULL | width == ERROR | height == ERROR ) { RET_ERR; }
    SDL_Window *result = gsdl_windowNew(title, width, height, flags);
    list_add(glua_windows, (void*)result);
    lua_pushinteger(context, item_newId(tag_windows, glua_windows->entries-1));
    return 1;
}

int glua_newRenderer(lua_State *context) {
    int flags = glua_getInt(context, "gfx.newRenderer", 2); if ( flags == ERROR ) { RET_ERR; }
    int index = glua_getInt(context, "gfx.newRenderer", 1); if ( index == ERROR ) { RET_ERR; }
    if ( item_isType(tag_windows, index) == false ) { glua_error(context, sdls_wrong_type, "gfx.newRenderer", 1); }
    SDL_Window *ref = item_byInt(index);
    if ( ref == NULL ) { glua_error(context, sdls_invalid_id, "gfx.newRenderer", 1); RET_ERR; }
    SDL_Renderer *result = gsdl_newRenderer(ref, flags);
    list_add(glua_renderers, (void*)result);
    lua_pushinteger(context, item_newId(tag_renderers, glua_renderers->entries-1));
    return 1;
}

int glua_presentRenderer(lua_State *context){
    int renderer_id = glua_getInt(context, "gfx.presentRenderer", 1); if ( renderer_id == ERROR ) { RET_ERR; }
    if ( item_isType(tag_renderers, renderer_id) == false) { glua_error(context, sdls_wrong_type, "gfx.presentRenderer", 1); RET_ERR; }
    SDL_Renderer *renderer = (SDL_Renderer*)item_byInt(renderer_id);
    if ( renderer == NULL ) { glua_error(context, sdls_invalid_id, "gfx.presentRenderer", 1); RET_ERR; }
    gsdl_presentRenderer(renderer);
    return OK;
}

int glua_destroyWindow(lua_State *context) {
    int id = glua_getInt(context, "gfx.destroyWindow", 1); if ( id == ERROR ) { RET_ERR; }
    if ( item_isType(tag_windows, id) == false ) { glua_error(context, sdls_wrong_type, "sdl_destroyWindow", 1); RET_ERR; }
    SDL_Window *ref = (SDL_Window*)item_byInt(id);
    if ( ref == NULL ) { glua_error(context, sdls_invalid_id, "gfx.destroyWindow", 1); RET_ERR; }
    gsdl_windowDestroy(ref);
    return OK; // no arguments returned
}

int glua_destroyRenderer(lua_State *context) {
    int id = glua_getInt(context, "gfx.destroyRenderer", 1); if ( id == ERROR ) { RET_ERR; }
    if ( item_isType(tag_renderers, id) == false) { glua_error(context, sdls_wrong_type, "sdl_destroyRenderer", 1); RET_ERR; }
    SDL_Renderer *ref = (SDL_Renderer*)item_byInt(id);
    if ( ref == NULL ) { glua_error(context, sdls_invalid_id, "gfx.destroyRenderer", 1); RET_ERR; }
    gsdl_rendererDestroy(ref);
    return OK;
}

int glua_loadTexture(lua_State *context) {
    const char *filename = glua_getString(context, "gfx.loadTexture", 2); if ( filename == NULL ) { RET_ERR; }
    int id = glua_getInt(context, "gfx.loadTexture", 1); if ( id == ERROR ) { RET_ERR; }
    if (item_isType(tag_renderers, id) == false) { glua_error(context, sdls_wrong_type, "sdl_loadTexture", 1); RET_ERR; }
    SDL_Renderer *ref = (SDL_Renderer*)item_byInt(id);
    if ( ref == NULL ) { glua_error(context, sdls_invalid_id, "sdl_loadTexture", 1); RET_ERR; }
    SDL_Texture *result = gsdl_loadTexture(ref, filename);
    if ( result == NULL ) { glua_error(context, sdls_unable_file, "sdl_loadTexture", 2); RET_ERR; }
    list_add(glua_textures, (void*)result);
    lua_pushinteger(context, item_newId(tag_textures, glua_textures->entries-1));
    return 1;
}

int glua_renderTexture(lua_State *context) {
    // Get the output destination within the rendering context
        SDL_Rect dest = glua_getBox(context, "renderTexture", 4); if ( &dest == &BadBox ) { glua_error(context, sdls_expect_table_bad, "sdl_sdl_renderTexture", 4); RET_ERR; }
    // Get the bounding box for the texture
        SDL_Rect source = glua_getBox(context, "renderTexture", 3); if ( &source == &BadBox ) { glua_error(context, sdls_expect_table_bad, "sdl_sdl_renderTexture", 3); RET_ERR; }
    // Get the texture
    int texture_id = glua_getInt(context, "renderTexture", 2); if ( texture_id == ERROR ) { RET_ERR; }
        if (item_isType(tag_textures, texture_id) == false) { glua_error(context, sdls_wrong_type, "sdl_renderTexture", 2); RET_ERR; }
        SDL_Texture *texture = (SDL_Texture*)item_byInt(texture_id);
        if ( texture == NULL ) { glua_error(context, sdls_invalid_id, "sdl_renderTexture", 2); RET_ERR; }
    // Get the renderer
    int renderer_id = glua_getInt(context, "gfx.renderTexture", 1); if ( renderer_id == ERROR ) { RET_ERR; }
        if (item_isType(tag_renderers, renderer_id) == false) { glua_error(context, sdls_wrong_type, "sdl_renderTexture", 1); RET_ERR; }
        SDL_Renderer *renderer = (SDL_Renderer*)item_byInt(renderer_id);
        if ( renderer == NULL ) { glua_error(context, sdls_invalid_id, "sdl_renderTexture", 1); RET_ERR; }
    // Call out
        int result = gsdl_renderTexture(renderer, texture, source, dest);
        if ( result != OK ) { glua_error(context, sdls_unable_render, "renderTexture", 4); RET_ERR; }
        return OK;
}

int glua_setColor(lua_State *context) {
    int alpha = glua_getInt(context, "gfx.setColor", 4);   if ( alpha == ERROR ) { RET_ERR; }
    int blue = glua_getInt(context, "gfx.setColor", 3);    if ( blue == ERROR ) { RET_ERR; }
    int green = glua_getInt(context, "gfx.setColor", 2);   if ( green == ERROR ) { RET_ERR; }
    int red = glua_getInt(context, "gfx.setColor", 1);     if ( red == ERROR ) { RET_ERR; }
    int id = glua_getInt(context, "gfx.setColor", 1);      if ( id == ERROR ) { RET_ERR; }
    if (item_isType(tag_renderers, id) == false) { glua_error(context, sdls_wrong_type, "gfx.setColor", 1); RET_ERR; }
    SDL_Renderer *ref = (SDL_Renderer*)item_byInt(id);
    if ( ref == NULL ) { glua_error(context, sdls_invalid_id, "gfx.setColor", 1); RET_ERR; }
    lua_pushinteger(context, gsdl_setColor(ref, red, green, blue, alpha));
    return 1;
}

int glua_clear(lua_State *context){
    int id = glua_getInt(context, "gfx.clear", 1); if ( id == ERROR ) { RET_ERR; }
    if (item_isType(tag_renderers, id) == false) { glua_error(context, sdls_wrong_type, "gfx.clear", 1); RET_ERR; }
    SDL_Renderer *ref = (SDL_Renderer*)item_byInt(id);
    gsdl_clear(ref);
    return OK;
}

int glua_delay(lua_State *context) {
    int ms = glua_getInt(context, "gfx.delay", 1); if ( ms == ERROR ) { RET_ERR; }
    gsdl_delay(ms);
    return OK;
}

// ================================ Stack Manipulation Functions

void glua_subfield_string(lua_State *state, const char *field, const char *value) {
    lua_pushstring(state, value);
    lua_setfield(state, -2, field);
}

void glua_subfield_int(lua_State *state, const char *field, int value) {
    lua_pushinteger(state, value);
    lua_setfield(state, -2, field);
}

void glua_enter_subtable(lua_State *state, const char *field) {
    lua_newtable(state);
    lua_setfield(state, -2, field);
    lua_getfield(state, -1, field);
}

// ========================== Entity System Functions

int glua_getByIdInt(lua_State *context) {
    int id = glua_getInt(context, "core.id", 1); if ( id == ERROR ) { RET_ERR; }
    void *reference = item_byInt(id);
    if ( reference == NULL ) { glua_error(context, sdls_invalid_id, "core.id", 1); }
    lua_pushlightuserdata(context, reference); // https://www.lua.org/pil/28.5.html
    return 1;
}

int glua_getByIdStr(lua_State *context) {
    const char *id = glua_getString(context, "core.parseid", 1); if ( id == NULL ) { RET_ERR; }
    void *reference = item_byStr(id);
    if ( reference == NULL ) { glua_error(context, sdls_invalid_id, "core.parseid", 1); }
    lua_pushlightuserdata(context, reference); // https://www.lua.org/pil/28.5.html
    return 1;
}

// ========================== Init

#define glua_initFunctionsDepth -2
void glua_method(lua_State *state, const char *name, lua_CFunction func) {
    lua_pushcfunction(state, func);
    lua_setfield(state, glua_initFunctionsDepth, name);
}

void glua_package_remove(lua_State *state, const char *package) {
    lua_pushnil(state); // Replace the metatable with a `nil` value
    lua_setglobal(state, package);
    lua_getglobal(state, "package"); // Also remove it from the packages table
    lua_getfield(state, -1, "loaded");
    lua_pushnil(state);
    lua_setfield(state, -2, "package");
    lua_pop(state, -1);
}

lua_State *glua_initFunctions() {
    // Push our data types to the global item table
    global_item_table = list_new(16);
    glua_windows = list_new(8); list_add(global_item_table, glua_windows);
    glua_renderers = list_new(8); list_add(global_item_table, glua_renderers);
    glua_textures = list_new(255); list_add(global_item_table, glua_textures);
    lua_State *globalState = luaL_newstate();
    luaL_openlibs(globalState);
    glua_package_remove(globalState, "os");
    // Remove 'os' from `package.loaded` too just in case anyone's trying to list the available packages
        lua_getglobal(globalState, "package");
        lua_getfield(globalState, -1, "loaded");
        lua_pushnil(globalState);
        lua_setfield(globalState, -2, "os");
    // Create empty lib tables
        lua_newtable(globalState);
        lua_setglobal(globalState, "core");
        lua_newtable(globalState);
        lua_setglobal(globalState, "gfx");
    // Set up CORE
        lua_getglobal(globalState, "core");
            glua_method(globalState, "exit", glua_exit);
            glua_method(globalState, "id", glua_getByIdInt);
            glua_method(globalState, "parseid", glua_getByIdStr);
        lua_pop(globalState, 1);
    // Set up GFX
        lua_getglobal(globalState, "gfx");
            glua_method(globalState, "newWindow",          glua_newWindow);
            glua_method(globalState, "destroyWindow",      glua_destroyWindow);
            glua_method(globalState, "newRenderer",        glua_newRenderer);
            glua_method(globalState, "destroyRenderer",    glua_destroyRenderer);
            glua_method(globalState, "presentRenderer",    glua_presentRenderer);
            glua_method(globalState, "loadTexture",        glua_loadTexture);
            glua_method(globalState, "renderTexture",      glua_renderTexture);
            glua_method(globalState, "setColor",           glua_setColor);
            glua_method(globalState, "clear",              glua_clear);
            glua_method(globalState, "delay",              glua_delay);
            glua_method(globalState, "eventPoll",          glua_pollEvent);
    // Events
        glua_enter_subtable(globalState, "event");
            glua_subfield_int(globalState, "type", -1);
            glua_subfield_int(globalState, "timestamp", -1);
            lua_pop(globalState, 1); // "events"
    // Flags    
        glua_enter_subtable(globalState, "flags");
            glua_enter_subtable(globalState, "window");
                glua_subfield_int(globalState, "FULLSCREEN",         0x00000001);
                glua_subfield_int(globalState, "OPENGL",             0x00000002);
                glua_subfield_int(globalState, "SHOWN",              0x00000004);
                glua_subfield_int(globalState, "HIDDEN",             0x00000008);
                glua_subfield_int(globalState, "BORDERLESS",         0x00000010);
                glua_subfield_int(globalState, "RESIZABLE",          0x00000020);
                glua_subfield_int(globalState, "MINIMIZED",          0x00000040);
                glua_subfield_int(globalState, "MAXIMIZED",          0x00000080);
                glua_subfield_int(globalState, "MOUSE_GRABBED",      0x00000100);
                glua_subfield_int(globalState, "INPUT_FOCUS",        0x00000200);
                glua_subfield_int(globalState, "MOUSE_FOCUS",        0x00000400);
                glua_subfield_int(globalState, "FULLSCREEN_DESKTOP", (0x00000001 | 0x00001000)); // FULLSCREEN | 0x00001000
                glua_subfield_int(globalState, "FOREIGN",            0x00000800);
                glua_subfield_int(globalState, "ALLOW_HIGHDPI",      0x00002000);
                glua_subfield_int(globalState, "MOUSE_CAPTURE",      0x00004000);
                glua_subfield_int(globalState, "ALWAYS_ON_TOP",      0x00008000);
                glua_subfield_int(globalState, "SKIP_TASKBAR",       0x00010000);
                glua_subfield_int(globalState, "UTILITY",            0x00020000);
                glua_subfield_int(globalState, "TOOLTIP",            0x00040000);
                glua_subfield_int(globalState, "POPUP_MENU",         0x00080000);
                glua_subfield_int(globalState, "KEYBOARD_GRABBED",   0x00100000);
                glua_subfield_int(globalState, "VULKAN",             0x10000000);
                glua_subfield_int(globalState, "METAL",              0x20000000);
                glua_subfield_int(globalState, "INPUT_GRABBED",      0x00000100);
                lua_pop(globalState, 1); // "window"
            glua_enter_subtable(globalState, "renderer");
                glua_subfield_int(globalState, "SOFTWARE",        0x00000001);
                glua_subfield_int(globalState, "ACCELERATED",     0x00000002);
                glua_subfield_int(globalState, "PRESENTVSYNC",    0x00000004);
                glua_subfield_int(globalState, "TARGETTEXTURE",   0x00000008);
                lua_pop(globalState, 1); // "renderer"
            glua_enter_subtable(globalState, "event");
                glua_subfield_int(globalState, "FIRSTEVENT", 0);
                glua_subfield_int(globalState, "QUIT", 0x100);
                glua_subfield_int(globalState, "APP_TERMINATING", 0x101);
                glua_subfield_int(globalState, "APP_LOWMEMORY", 0x102);
                glua_subfield_int(globalState, "APP_WILLENTERBACKGROUND", 0x103);
                glua_subfield_int(globalState, "APP_DIDENTERBACKGROUND", 0x104);
                glua_subfield_int(globalState, "APP_WILLENTERFOREGROUND", 0x105);
                glua_subfield_int(globalState, "APP_DIDENTERFOREGROUND", 0x106);
                glua_subfield_int(globalState, "LOCALECHANGED", 0x107);
                glua_subfield_int(globalState, "DISPLAYEVENT", 0x150);
                // Window Events
                glua_subfield_int(globalState, "WINDOWEVENT", 0x200);
                    glua_enter_subtable(globalState, "window");
                        glua_subfield_int(globalState, "NONE", 0);
                        glua_subfield_int(globalState, "SHOWN", 1);
                        glua_subfield_int(globalState, "HIDDEN", 2);
                        glua_subfield_int(globalState, "EXPOSED", 3);
                        glua_subfield_int(globalState, "MOVED", 4);
                        glua_subfield_int(globalState, "RESIZED", 5);
                        glua_subfield_int(globalState, "SIZE_CHANGED", 6);
                        glua_subfield_int(globalState, "MINIMIZED", 7);
                        glua_subfield_int(globalState, "MAXIMIZED", 8);
                        glua_subfield_int(globalState, "RESTORED", 9);
                        glua_subfield_int(globalState, "ENTER", 10);
                        glua_subfield_int(globalState, "LEAVE", 11);
                        glua_subfield_int(globalState, "FOCUS_GAINED", 12);
                        glua_subfield_int(globalState, "FOCUS_LOST", 13);
                        glua_subfield_int(globalState, "CLOSE", 14);
                        glua_subfield_int(globalState, "TAKE_FOCUS", 15);
                        glua_subfield_int(globalState, "HIT_TEST", 16);
                        glua_subfield_int(globalState, "ICCPROF_CHANGED", 17);
                        glua_subfield_int(globalState, "DISPLAY_CHANGED", 18);
                    lua_pop(globalState, 1); // "gfx.flags.event.window"
                glua_subfield_int(globalState, "SYSWMEVENT", 0x201);
                glua_subfield_int(globalState, "KEYDOWN", 0x300);
                glua_subfield_int(globalState, "KEYUP", 0x301);
                glua_subfield_int(globalState, "TEXTEDITING", 0x302);
                glua_subfield_int(globalState, "TEXTINPUT", 0x303);
                glua_subfield_int(globalState, "KEYMAPCHANGED", 0x304);
                glua_subfield_int(globalState, "TEXTEDITING_EXT", 0x305);
                glua_subfield_int(globalState, "MOUSEMOTION", 0x400);
                glua_subfield_int(globalState, "MOUSEBUTTONDOWN", 0x401);
                glua_subfield_int(globalState, "MOUSEBUTTONUP", 0x402);
                glua_subfield_int(globalState, "MOUSEWHEEL", 0x403);
                glua_subfield_int(globalState, "JOYAXISMOTION", 0x600);
                glua_subfield_int(globalState, "JOYBALLMOTION", 0x601);
                glua_subfield_int(globalState, "JOYHATMOTION", 0x602);
                glua_subfield_int(globalState, "JOYBUTTONDOWN", 0x603);
                glua_subfield_int(globalState, "JOYBUTTONUP", 0x604);
                glua_subfield_int(globalState, "JOYDEVICEADDED", 0x605);
                glua_subfield_int(globalState, "JOYDEVICEREMOVED", 0x606);
                glua_subfield_int(globalState, "JOYBATTERYUPDATED", 0x607);
                glua_subfield_int(globalState, "CONTROLLERAXISMOTION", 0x650);
                glua_subfield_int(globalState, "CONTROLLERBUTTONDOWN", 0x651);
                glua_subfield_int(globalState, "CONTROLLERBUTTONUP", 0x652);
                glua_subfield_int(globalState, "CONTROLLERDEVICEADDED", 0x653);
                glua_subfield_int(globalState, "CONTROLLERDEVICEREMOVED", 0x654);
                glua_subfield_int(globalState, "CONTROLLERDEVICEREMAPPED", 0x655);
                glua_subfield_int(globalState, "CONTROLLERTOUCHPADDOWN", 0x656);
                glua_subfield_int(globalState, "CONTROLLERTOUCHPADMOTION", 0x657);
                glua_subfield_int(globalState, "CONTROLLERTOUCHPADUP", 0x658);
                glua_subfield_int(globalState, "CONTROLLERSENSORUPDATE", 0x659);
                glua_subfield_int(globalState, "CONTROLLERUPDATECOMPLETE_RESERVED_FOR_SDL3", 0x65A);
                glua_subfield_int(globalState, "CONTROLLERSTEAMHANDLEUPDATED", 0x65B);
                glua_subfield_int(globalState, "FINGERDOWN", 0x700);
                glua_subfield_int(globalState, "FINGERUP", 0x701);
                glua_subfield_int(globalState, "FINGERMOTION", 0x702);
                glua_subfield_int(globalState, "DOLLARGESTURE", 0x800);
                glua_subfield_int(globalState, "DOLLARRECORD", 0x801);
                glua_subfield_int(globalState, "MULTIGESTURE", 0x802);
                glua_subfield_int(globalState, "CLIPBOARDUPDATE", 0x900);
                glua_subfield_int(globalState, "DROPFILE", 0x1000);
                glua_subfield_int(globalState, "DROPTEXT", 0x1001);
                glua_subfield_int(globalState, "DROPBEGIN", 0x1002);
                glua_subfield_int(globalState, "DROPCOMPLETE", 0x1003);
                glua_subfield_int(globalState, "AUDIODEVICEADDED", 0x1100);
                glua_subfield_int(globalState, "AUDIODEVICEREMOVED", 0x1101);
                glua_subfield_int(globalState, "SENSORUPDATE", 0x1200);
                glua_subfield_int(globalState, "RENDER_TARGETS_RESET", 0x2000);
                glua_subfield_int(globalState, "RENDER_DEVICE_RESET", 0x2001);
                glua_subfield_int(globalState, "POLLSENTINEL", 0x7F00);
                glua_subfield_int(globalState, "USEREVENT", 0x8000);
                glua_subfield_int(globalState, "LASTEVENT", 0xFFFF);
                lua_pop(globalState, 1); // "events"
            lua_pop(globalState, 1); // "flags"
        lua_pop(globalState, 1); // "gfx"
    return globalState;
} // glua source
#ifndef MOONGIN 
    #include "includes.h"
#endif
// ================================ The Event Router

int glua_pollEvent(lua_State *context) {
    gsdl_pollEvent();
    lua_getglobal(context, "gfx");
    lua_getfield(context, -1, "event");
    // Populate common attributes before returning
    glua_subfield_int(context, "type", eventHandle.common.type);
    glua_subfield_int(context, "timestamp", eventHandle.common.timestamp);
        switch( eventHandle.type ) {
        case SDL_POLLSENTINEL: break; // specifically nothing happened
        default: printf("_pollEvent: unhandled type %x\n", eventHandle.type); break;
        case SDL_WINDOWEVENT: printf("_pollEvent: Window Event %x sub %d\n", eventHandle.type, eventHandle.window.event); glua_event_window(context); break;
        case SDL_KEYDOWN: case SDL_KEYUP: printf("_pollEvent: Keyboard Event %x\n", eventHandle.type); glua_event_keyboard(context); break;
    }

    lua_pop(context, 2); // pop "gfx" and "event"
    return OK;
}

// ================================ Event Type Handlers

void glua_event_window(lua_State *context) {
    SDL_Window *window = SDL_GetWindowFromID(eventHandle.window.windowID);
    int window_id = list_index(glua_windows, window);
    glua_subfield_int(context, "window", window_id);
    glua_subfield_int(context, "event", eventHandle.window.event);
    glua_subfield_int(context, "data1", eventHandle.window.data1);
    glua_subfield_int(context, "data2", eventHandle.window.data2);
}

void glua_event_keyboard(lua_State *context) {
    SDL_Window *window = SDL_GetWindowFromID(eventHandle.key.windowID);
    int window_id = list_index(glua_windows, window);
    glua_subfield_int(context, "window", window_id);
    glua_subfield_int(context, "state", eventHandle.key.state);
    glua_subfield_int(context, "repeat", eventHandle.key.repeat);
    glua_subfield_int(context, "keycode", (eventHandle.key.keysym.sym));
    glua_subfield_int(context, "scancode", (eventHandle.key.keysym.scancode));
} // event source
char lua_entry[] = {
    0x1b,0x4c,0x75,0x61,0x54,0x00,0x19,0x93,0x0d,0x0a,0x1a,0x0a,0x04,0x08,0x08,0x78,
    0x56,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x77,0x40,0x01,
    0x94,0x40,0x2e,0x2f,0x68,0x65,0x6c,0x70,0x65,0x72,0x73,0x2f,0x6d,0x61,0x69,0x6e,
    0x2e,0x6c,0x75,0x61,0x80,0x80,0x00,0x01,0x1a,0x01,0xf1,0x51,0x00,0x00,0x00,0x0b,
    0x00,0x00,0x00,0x0e,0x00,0x00,0x01,0x83,0x00,0x01,0x00,0x01,0x81,0x8f,0x81,0x81,
    0x81,0x2b,0x81,0x0b,0x02,0x00,0x00,0x0e,0x02,0x04,0x03,0x0e,0x02,0x04,0x04,0x0e,
    0x02,0x04,0x05,0x44,0x00,0x05,0x02,0x8b,0x00,0x00,0x06,0x0b,0x01,0x00,0x07,0x0e,
    0x01,0x02,0x08,0x83,0x81,0x04,0x00,0x00,0x02,0x00,0x00,0x44,0x01,0x03,0x00,0xc4,
    0x00,0x00,0x01,0x8b,0x00,0x00,0x00,0x8e,0x00,0x01,0x0a,0x00,0x01,0x00,0x00,0x81,
    0x81,0xff,0x7f,0xc4,0x00,0x03,0x02,0x0b,0x01,0x00,0x06,0x8b,0x01,0x00,0x07,0x8e,
    0x01,0x03,0x08,0x03,0x82,0x05,0x00,0x80,0x02,0x01,0x00,0xc4,0x01,0x03,0x00,0x44,
    0x01,0x00,0x01,0x0b,0x01,0x00,0x00,0x0e,0x01,0x02,0x0c,0x80,0x01,0x01,0x00,0x03,
    0x82,0x06,0x00,0x44,0x01,0x03,0x02,0x8b,0x01,0x00,0x06,0x0b,0x02,0x00,0x07,0x0e,
    0x02,0x04,0x08,0x83,0x02,0x07,0x00,0x00,0x03,0x02,0x00,0x44,0x02,0x03,0x00,0xc4,
    0x01,0x00,0x01,0x81,0x81,0x0e,0x80,0x4f,0x02,0x00,0x00,0xcf,0x82,0x00,0x00,0x4f,
    0x03,0x01,0x00,0x93,0x03,0x00,0x07,0x52,0x00,0x00,0x00,0x00,0x04,0x05,0x00,0x81,
    0x04,0x7f,0x80,0x01,0x85,0xff,0x7f,0x81,0x85,0xff,0x7f,0x44,0x04,0x04,0x02,0x80,
    0x04,0x05,0x00,0x01,0x85,0xff,0x7f,0x81,0x05,0x7f,0x80,0x01,0x86,0xff,0x7f,0xc4,
    0x04,0x04,0x02,0x00,0x05,0x05,0x00,0x81,0x85,0xff,0x7f,0x01,0x86,0xff,0x7f,0x81,
    0x06,0x7f,0x80,0x44,0x05,0x04,0x02,0x80,0x05,0x05,0x00,0x01,0x06,0x7f,0x80,0x81,
    0x06,0x7f,0x80,0x01,0x87,0xff,0x7f,0xc4,0x05,0x04,0x02,0x00,0x06,0x05,0x00,0x81,
    0x86,0xff,0x7f,0x01,0x07,0x7f,0x80,0x81,0x07,0x7f,0x80,0x44,0x06,0x04,0x02,0x80,
    0x06,0x05,0x00,0x01,0x07,0x7f,0x80,0x81,0x87,0xff,0x7f,0x01,0x08,0x7f,0x80,0xc4,
    0x06,0x04,0x02,0x00,0x07,0x05,0x00,0x81,0x07,0x7f,0x80,0x01,0x08,0x7f,0x80,0x81,
    0x08,0x7f,0x80,0x44,0x07,0x04,0x02,0x80,0x07,0x05,0x00,0x01,0x88,0xff,0x7f,0x81,
    0x88,0xff,0x7f,0x01,0x89,0xff,0x7f,0xc4,0x07,0x04,0x00,0xce,0x03,0x00,0x00,0x13,
    0x04,0x03,0x00,0x52,0x00,0x00,0x00,0x12,0x84,0x0f,0x10,0x12,0x84,0x11,0x10,0x12,
    0x84,0x12,0x13,0x12,0x84,0x14,0x13,0x93,0x04,0x03,0x00,0x52,0x00,0x00,0x00,0x92,
    0x84,0x0f,0x15,0x92,0x84,0x11,0x15,0x92,0x84,0x12,0x16,0x92,0x84,0x14,0x17,0x0b,
    0x05,0x00,0x00,0x0e,0x05,0x0a,0x18,0x80,0x05,0x01,0x00,0x01,0x86,0xff,0x7f,0x81,
    0x86,0xff,0x7f,0x01,0x87,0xff,0x7f,0x81,0x07,0x7f,0x80,0x44,0x05,0x06,0x01,0x0b,
    0x05,0x00,0x00,0x0e,0x05,0x0a,0x19,0x80,0x05,0x01,0x00,0x44,0x05,0x02,0x01,0x0b,
    0x05,0x00,0x06,0x83,0x05,0x0d,0x00,0x44,0x05,0x02,0x01,0x0b,0x05,0x00,0x06,0x8b,
    0x05,0x00,0x00,0x8e,0x05,0x0b,0x03,0x8e,0x05,0x0b,0x1b,0x8e,0x05,0x0b,0x1c,0x44,
    0x05,0x02,0x01,0x01,0x05,0x00,0x80,0x81,0x85,0x95,0x80,0x01,0x06,0x00,0x80,0x4a,
    0x85,0x28,0x00,0x0b,0x07,0x00,0x1d,0x80,0x07,0x07,0x00,0x44,0x07,0x02,0x05,0x4b,
    0x07,0x25,0x00,0x0b,0x0a,0x00,0x00,0x0e,0x0a,0x14,0x18,0x80,0x0a,0x01,0x00,0x0d,
    0x0b,0x13,0x01,0x8d,0x0b,0x13,0x02,0x0d,0x0c,0x13,0x03,0x8d,0x0c,0x13,0x04,0x44,
    0x0a,0x06,0x01,0x0b,0x0a,0x00,0x00,0x0e,0x0a,0x14,0x19,0x80,0x0a,0x01,0x00,0x44,
    0x0a,0x02,0x01,0x0b,0x0a,0x00,0x00,0x0e,0x0a,0x14,0x1e,0x80,0x0a,0x01,0x00,0x00,
    0x0b,0x02,0x00,0x80,0x0b,0x09,0x00,0x00,0x0c,0x08,0x00,0x44,0x0a,0x05,0x01,0x0b,
    0x0a,0x00,0x00,0x0e,0x0a,0x14,0x1f,0x80,0x0a,0x01,0x00,0x44,0x0a,0x02,0x01,0x0b,
    0x0a,0x00,0x00,0x0e,0x0a,0x14,0x20,0x44,0x0a,0x01,0x01,0x0b,0x0a,0x00,0x00,0x0e,
    0x0a,0x14,0x1b,0x0e,0x0a,0x14,0x21,0x8b,0x0a,0x00,0x00,0x8e,0x0a,0x15,0x03,0x8e,
    0x0a,0x15,0x1b,0x8e,0x0a,0x15,0x1c,0x39,0x0a,0x15,0x00,0xb8,0x03,0x00,0x80,0x0b,
    0x0a,0x00,0x06,0x83,0x0a,0x11,0x00,0x44,0x0a,0x02,0x01,0x0b,0x0a,0x00,0x23,0x0e,
    0x0a,0x14,0x24,0x81,0x8a,0xff,0x7f,0x44,0x0a,0x02,0x01,0x38,0x0f,0x00,0x80,0x0b,
    0x0a,0x00,0x00,0x0e,0x0a,0x14,0x1b,0x0e,0x0a,0x14,0x21,0x8b,0x0a,0x00,0x00,0x8e,
    0x0a,0x15,0x03,0x8e,0x0a,0x15,0x1b,0x8e,0x0a,0x15,0x25,0x39,0x0a,0x15,0x00,0xb8,
    0x08,0x00,0x80,0x0b,0x0a,0x00,0x00,0x0e,0x0a,0x14,0x1b,0x0e,0x0a,0x14,0x1b,0x8b,
    0x0a,0x00,0x00,0x8e,0x0a,0x15,0x03,0x8e,0x0a,0x15,0x1b,0x8e,0x0a,0x15,0x04,0x8e,
    0x0a,0x15,0x26,0x39,0x0a,0x15,0x00,0xb8,0x05,0x00,0x80,0x0b,0x0a,0x00,0x06,0x83,
    0x8a,0x13,0x00,0x44,0x0a,0x02,0x01,0x0b,0x0a,0x00,0x23,0x0e,0x0a,0x14,0x24,0x81,
    0x8a,0xff,0x7f,0x44,0x0a,0x02,0x01,0xb8,0x01,0x00,0x80,0x0b,0x0a,0x00,0x00,0x0e,
    0x0a,0x14,0x28,0x80,0x0a,0x03,0x00,0x44,0x0a,0x02,0x01,0x4c,0x07,0x00,0x02,0x4d,
    0x07,0x26,0x00,0x36,0x07,0x00,0x00,0x49,0x05,0x29,0x00,0x0b,0x05,0x00,0x06,0x8b,
    0x05,0x00,0x07,0x8e,0x05,0x0b,0x08,0x03,0x86,0x14,0x00,0x80,0x06,0x01,0x00,0x0b,
    0x07,0x00,0x23,0x0e,0x07,0x0e,0x2a,0x80,0x07,0x01,0x00,0x44,0x07,0x02,0x00,0xc4,
    0x05,0x00,0x00,0x44,0x05,0x00,0x01,0x0b,0x05,0x00,0x06,0x8b,0x05,0x00,0x07,0x8e,
    0x05,0x0b,0x08,0x03,0x86,0x15,0x00,0x8b,0x06,0x00,0x2c,0x00,0x07,0x01,0x00,0xc4,
    0x06,0x02,0x02,0x0b,0x07,0x00,0x23,0x0e,0x07,0x0e,0x2a,0x80,0x07,0x01,0x00,0x44,
    0x07,0x02,0x00,0xc4,0x05,0x00,0x00,0x44,0x05,0x00,0x01,0x0b,0x05,0x00,0x00,0x0e,
    0x05,0x0a,0x2d,0x80,0x05,0x01,0x00,0x44,0x05,0x02,0x01,0x0b,0x05,0x00,0x00,0x0e,
    0x05,0x0a,0x2e,0x80,0x05,0x00,0x00,0x44,0x05,0x02,0x01,0x46,0x85,0x01,0x01,0xaf,
    0x04,0x84,0x67,0x66,0x78,0x04,0x8a,0x6e,0x65,0x77,0x57,0x69,0x6e,0x64,0x6f,0x77,
    0x04,0x8c,0x54,0x65,0x73,0x74,0x20,0x57,0x69,0x6e,0x64,0x6f,0x77,0x04,0x86,0x66,
    0x6c,0x61,0x67,0x73,0x04,0x87,0x77,0x69,0x6e,0x64,0x6f,0x77,0x04,0x86,0x53,0x48,
    0x4f,0x57,0x4e,0x04,0x86,0x70,0x72,0x69,0x6e,0x74,0x04,0x87,0x73,0x74,0x72,0x69,
    0x6e,0x67,0x04,0x87,0x66,0x6f,0x72,0x6d,0x61,0x74,0x04,0x92,0x4e,0x65,0x77,0x20,
    0x77,0x69,0x6e,0x64,0x6f,0x77,0x3a,0x20,0x09,0x25,0x30,0x38,0x78,0x04,0x8c,0x6e,
    0x65,0x77,0x52,0x65,0x6e,0x64,0x65,0x72,0x65,0x72,0x04,0x94,0x4e,0x65,0x77,0x20,
    0x72,0x65,0x6e,0x64,0x65,0x72,0x65,0x72,0x3a,0x20,0x09,0x25,0x30,0x38,0x78,0x04,
    0x8c,0x6c,0x6f,0x61,0x64,0x54,0x65,0x78,0x74,0x75,0x72,0x65,0x04,0x92,0x2e,0x2f,
    0x61,0x73,0x73,0x65,0x74,0x73,0x2f,0x64,0x75,0x63,0x6b,0x2e,0x70,0x6e,0x67,0x04,
    0x94,0x44,0x75,0x63,0x6b,0x20,0x74,0x65,0x78,0x74,0x75,0x72,0x65,0x3a,0x20,0x09,
    0x25,0x30,0x38,0x78,0x04,0x82,0x78,0x03,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x04,0x82,0x79,0x04,0x82,0x77,0x03,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,
    0x82,0x68,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xe4,0x05,0x00,0x00,
    0x00,0x00,0x00,0x00,0x03,0xea,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x89,0x73,
    0x65,0x74,0x43,0x6f,0x6c,0x6f,0x72,0x04,0x86,0x63,0x6c,0x65,0x61,0x72,0x14,0xaf,
    0x77,0x61,0x69,0x74,0x69,0x6e,0x67,0x20,0x66,0x6f,0x72,0x20,0x61,0x20,0x51,0x55,
    0x49,0x54,0x20,0x65,0x76,0x65,0x6e,0x74,0x2c,0x20,0x77,0x68,0x69,0x63,0x68,0x20,
    0x6c,0x6f,0x6f,0x6b,0x73,0x20,0x6c,0x69,0x6b,0x65,0x20,0x3e,0x3e,0x20,0x04,0x86,
    0x65,0x76,0x65,0x6e,0x74,0x04,0x85,0x51,0x55,0x49,0x54,0x04,0x87,0x69,0x70,0x61,
    0x69,0x72,0x73,0x04,0x8e,0x72,0x65,0x6e,0x64,0x65,0x72,0x54,0x65,0x78,0x74,0x75,
    0x72,0x65,0x04,0x90,0x70,0x72,0x65,0x73,0x65,0x6e,0x74,0x52,0x65,0x6e,0x64,0x65,
    0x72,0x65,0x72,0x04,0x8a,0x65,0x76,0x65,0x6e,0x74,0x50,0x6f,0x6c,0x6c,0x04,0x85,
    0x74,0x79,0x70,0x65,0x04,0x95,0x4b,0x49,0x4c,0x4c,0x20,0x53,0x49,0x47,0x4e,0x41,
    0x4c,0x20,0x52,0x45,0x43,0x45,0x49,0x56,0x45,0x44,0x04,0x85,0x63,0x6f,0x72,0x65,
    0x04,0x85,0x65,0x78,0x69,0x74,0x04,0x8c,0x57,0x49,0x4e,0x44,0x4f,0x57,0x45,0x56,
    0x45,0x4e,0x54,0x04,0x86,0x43,0x4c,0x4f,0x53,0x45,0x04,0x96,0x43,0x4c,0x4f,0x53,
    0x45,0x20,0x53,0x49,0x47,0x4e,0x41,0x4c,0x20,0x52,0x45,0x43,0x45,0x49,0x56,0x45,
    0x44,0x04,0x86,0x64,0x65,0x6c,0x61,0x79,0x04,0x9f,0x65,0x6e,0x74,0x69,0x74,0x79,
    0x20,0x69,0x64,0x20,0x25,0x30,0x38,0x78,0x2c,0x20,0x70,0x6f,0x69,0x6e,0x74,0x65,
    0x72,0x20,0x74,0x6f,0x20,0x2a,0x25,0x70,0x04,0x83,0x69,0x64,0x04,0x9f,0x65,0x6e,
    0x74,0x69,0x74,0x79,0x20,0x69,0x64,0x20,0x22,0x25,0x73,0x22,0x2c,0x20,0x70,0x6f,
    0x69,0x6e,0x74,0x65,0x72,0x20,0x74,0x6f,0x20,0x2a,0x25,0x70,0x04,0x89,0x74,0x6f,
    0x73,0x74,0x72,0x69,0x6e,0x67,0x04,0x90,0x64,0x65,0x73,0x74,0x72,0x6f,0x79,0x52,
    0x65,0x6e,0x64,0x65,0x72,0x65,0x72,0x04,0x8e,0x64,0x65,0x73,0x74,0x72,0x6f,0x79,
    0x57,0x69,0x6e,0x64,0x6f,0x77,0x81,0x01,0x00,0x00,0x83,0x80,0x8a,0x8a,0x04,0x00,
    0x05,0x88,0x13,0x02,0x03,0x00,0x52,0x00,0x00,0x00,0x12,0x02,0x00,0x00,0x12,0x02,
    0x01,0x01,0x12,0x02,0x02,0x02,0x12,0x02,0x03,0x03,0x48,0x02,0x02,0x00,0x47,0x02,
    0x01,0x00,0x84,0x04,0x82,0x78,0x04,0x82,0x79,0x04,0x82,0x77,0x04,0x82,0x68,0x80,
    0x80,0x88,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x84,0x82,0x78,0x80,0x88,
    0x82,0x79,0x80,0x88,0x82,0x77,0x80,0x88,0x82,0x68,0x80,0x88,0x80,0x80,0x8b,0x8b,
    0x03,0x00,0x08,0x89,0x93,0x01,0x00,0x04,0x52,0x00,0x00,0x00,0x00,0x02,0x00,0x00,
    0x80,0x02,0x01,0x00,0x00,0x03,0x02,0x00,0x81,0x03,0x7f,0x80,0xce,0x01,0x04,0x00,
    0xc8,0x01,0x02,0x00,0xc7,0x01,0x01,0x00,0x80,0x80,0x80,0x89,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x80,0x83,0x82,0x72,0x80,0x89,0x82,0x67,0x80,0x89,0x82,
    0x62,0x80,0x89,0x80,0x80,0x8c,0x8c,0x04,0x00,0x09,0x89,0x13,0x02,0x00,0x04,0x52,
    0x00,0x00,0x00,0x80,0x02,0x00,0x00,0x00,0x03,0x01,0x00,0x80,0x03,0x02,0x00,0x00,
    0x04,0x03,0x00,0x4e,0x02,0x04,0x00,0x48,0x02,0x02,0x00,0x47,0x02,0x01,0x00,0x80,
    0x80,0x80,0x89,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x84,0x82,0x72,
    0x80,0x89,0x82,0x67,0x80,0x89,0x82,0x62,0x80,0x89,0x82,0x61,0x80,0x89,0x80,0x01,
    0xf1,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x02,0x01,0x01,0x02,
    0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,
    0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,
    0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,
    0x01,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
    0x00,0x00,0x02,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x01,
    0x00,0x80,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,
    0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0xf7,0x00,0x0b,
    0xf4,0x0e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,
    0x00,0x00,0x81,0x01,0x80,0xa3,0x94,0x87,0x77,0x69,0x6e,0x64,0x6f,0x77,0x8b,0x01,
    0xf1,0x89,0x72,0x65,0x6e,0x64,0x65,0x72,0x65,0x72,0x97,0x01,0xf1,0x88,0x74,0x65,
    0x78,0x74,0x75,0x72,0x65,0xa3,0x01,0xf1,0x8b,0x66,0x72,0x61,0x6d,0x65,0x4c,0x69,
    0x6d,0x69,0x74,0xab,0x01,0xf1,0x84,0x62,0x6f,0x78,0xac,0x01,0xf1,0x84,0x72,0x67,
    0x62,0xad,0x01,0xf1,0x85,0x72,0x67,0x62,0x61,0xae,0x01,0xf1,0x87,0x63,0x6f,0x6c,
    0x6f,0x72,0x73,0xd9,0x01,0xf1,0x8b,0x72,0x65,0x6e,0x64,0x65,0x72,0x41,0x72,0x65,
    0x61,0xdf,0x01,0xf1,0x8b,0x74,0x65,0x78,0x74,0x75,0x72,0x65,0x42,0x6f,0x78,0xe5,
    0x01,0xf1,0x8c,0x28,0x66,0x6f,0x72,0x20,0x73,0x74,0x61,0x74,0x65,0x29,0xfd,0x01,
    0xd0,0x8c,0x28,0x66,0x6f,0x72,0x20,0x73,0x74,0x61,0x74,0x65,0x29,0xfd,0x01,0xd0,
    0x8c,0x28,0x66,0x6f,0x72,0x20,0x73,0x74,0x61,0x74,0x65,0x29,0xfd,0x01,0xd0,0x82,
    0x69,0xfe,0x01,0xcf,0x8c,0x28,0x66,0x6f,0x72,0x20,0x73,0x74,0x61,0x74,0x65,0x29,
    0x01,0x81,0x01,0xce,0x8c,0x28,0x66,0x6f,0x72,0x20,0x73,0x74,0x61,0x74,0x65,0x29,
    0x01,0x81,0x01,0xce,0x8c,0x28,0x66,0x6f,0x72,0x20,0x73,0x74,0x61,0x74,0x65,0x29,
    0x01,0x81,0x01,0xce,0x8c,0x28,0x66,0x6f,0x72,0x20,0x73,0x74,0x61,0x74,0x65,0x29,
    0x01,0x81,0x01,0xce,0x82,0x69,0x01,0x82,0x01,0xcc,0x86,0x63,0x6f,0x6c,0x6f,0x72,
    0x01,0x82,0x01,0xcc,0x81,0x85,0x5f,0x45,0x4e,0x56,0x00
};
 // luac payload

int main (int argc, char **argv) {
    lua_State *globalState = glua_initFunctions();
    int code = glua_byterun(globalState, lua_entry, sizeof(lua_entry));
}